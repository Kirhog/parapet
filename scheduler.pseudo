Scheduler {
    lock: Lock
    workers: Map[ProcessRef, Worker]
    queue: TaskQueue
    idleWorkers: Ref[LinkedSet]

    def run() = {
        def step() = {
            task: = queue.dequeue
            lock.acquire = submitTask(task)
            GUARANTEE: lock.release
            step()
        }
        step()
    }

    def submitTask(task: Task) = {
        worker: = workers.get(task.receiver)
        if (worker.queue.tryEnqueue(time)) {
            return
        } else {
            if (idleWorkers.notEmpty) {
                (process, tasks, status): = worker.steal(time)
                if (status != Success) {
                    submitTask(task)
                } else {
                    idleWorker: = idleWorkers.removeHead
                    workers += (process - > idleWorker)
                    idleWorker.addProcess(process)
                    for (t: tasks) {
                        submitTask(t)
                    }
                    submitTask(task)
                }
            }
        }
    }
}


Worker {
    queueReadLock: Lock
    schedulerLock: Lock
    queue: TaskQueue
    processes: Map[ProcessRef, Process]
    workers: Map[ProcessRef, Worker]
    currentProcess: Ref[ProcessRef]

    def run() {
        def step() = {
            task: = None
            queueReadLock.acquire
            task = queue.tryDequeue(time)
            if (!task) {
                task = stealTasks()
            }
            if (task) {
                currentProcess.set(task.receiver)
            } else {
                currentProcess.set(None)
            }
            queueReadLock.release

            if (task) {
                removeSelfFromIdleList()
                processTask(task)
                currentTaskProcessRef.set(None)
            }
            step() // repeat
        }
        step()
    }

    def stealTasks() = {
        addSelfToIdleList()
        task: = None
        if (schedulerLock.tryAcquire(time)) {
            task = queue.tryDequeue(time)
            if (task) return task // worker received new tasks
            victim: = chooseWorker(process, tasks, status): = victim.steal(time)
            if (status != Success) {
                return None
            } else {
                workers += (process - > self)
                removeSelfFromIdleList()
                    (head, tail): = tasks
                queue.enqueueAll(tail)
                return head
            }

            GUARANTEE: schedulerLock.release
        } else {
            return None
        }
    }

    def steal(time) = {
        if (queueReadLock.tryAcquire(time)) {
            victimProcess = chooseProcess
            tasks = queue.filter(task => task.receiver == victimProcess)
            return (victimProcess, tasks)

            GUARANTEE: queueReadLock.release
        } else {
            return None
        }
    }

}